\chapter{Optimizations}

Modern SAT solvers use many advanced optimizations and heuristics to improve the solving time.
However these are usually designed for general problem instances.
With additional knowledge about a specific problem we can try to come up with better rules which lead to decrease of solving time.

In this chapter we will describe several optimizations that we implemented and evaluated.
Some of these involve a simple change in output instance generation, others involve changes to the SAT solvers themselves.

\section{Expression encoding}
\label{sec:expression-encoding}
The automatic and transparent conversion from unmodified source code to SAT instance via operator overloading and boolean circuits may lead to suboptimal encoding of various expressions.
For example, the \emph{choice} round function in \emph{SHA-1}
\[
Ch(x, y, z) = (x \land y) \oplus (\overline{x} \land z)
\]
leads to an encoding with three variables and ten clauses (three clauses for each \emph{and} gate and four for the \emph{xor} gate) if we apply the Tseitin transformation directly:

% Naive Tseitin
% 1x 2y 3leftand 4notx 5z 6rightand 7result
%%%%%
%-3 1 0
%-3 2 0
%3 -1 -2 0
%4 1 0
%-4 -1 0
%-6 4 0
%-6 5 0
%6 -4 -5 0
%3 6 -7 0
%3 -6 7 0
%-3 6 7 0
%-3 -6 -7 0
\begin{align*}
(\overline{a} \lor x) \land (\overline{a} \lor y) \land (a \lor \overline{x} \lor \overline{y}) &~& \text{Left AND gate}\\
(\overline{b} \lor \overline{x}) \lor (\overline{b} \lor z) \lor (b \lor x \lor \overline{z})&~& \text{Right AND gate} \\
(c \lor a \lor \overline{b}) \land (c \lor \overline{a} \lor b) \land (\overline{c} \lor a \lor b) \land (\overline{c} \lor \overline{a} \lor \overline{b}) &~& \text{XOR gate}
\end{align*}

A better encoding using just six clauses and one variable is shown in \cite{nossum2012sat}:
\begin{align*}
&(\overline{a} \lor \overline{x} \lor y) \land (\overline{a} \lor x \lor z) \land (\overline{a} \lor y \lor z) \\
\land~ &(a \lor \overline{x} \lor \overline{y}) \land (a \lor x \lor \overline{z}) \land (a \lor \overline{y} \lor \overline{z})
\end{align*}

In fact, it is possible to encode this expression with just four clauses and one variable:
% Espresso opt
% 1x 2y 3z 4result
%%%%%
%-1 -2  4 0
%1 -3  4 0
%1 3  -4 0
%-1 2  -4 0
\begin{align*}
&(a \lor \overline{x} \lor \overline{y}) \land (a \lor x \lor \overline{z}) \land (\overline{a} \lor x \lor z) \land (\overline{a} \lor \overline{x} \lor y)
\end{align*}


%TODO move to section2 (library) after tseitin/boolean?
To solve this issue we provide an expression optimization function in our library.
Any $n$-ary expression can be wrapped using this function to replace the standard Tseitin encoding with a (potentially) smaller one, in terms of number of extra variables and clauses required.

First we evaluate the expression on all $2^n$ possible inputs to generate a truth table.
It is then processed using an external truth table minimization tool \emph{Espresso} \cite{rudell1986multiple}, which generates a list of clauses that can be used to encode the expression.
When this expression is used anywhere in the model a node is created in the boolean circuit representation.
It behaves like any other node and can be used in further expressions, however during instance generation the optimized list of clauses is used instead of the na\"{\i}ve Tseitin encoding.

Using this optimization on the \emph{SHA-1} \emph{choice} round function does indeed lead to the minimal encoding with just four clauses as shown above.
Similarly, some steps of the \emph{SHA-3} hash function can be wrapped and optimized in this way.
Both of these optimizations are further described and evaluated in section \ref{sec:expression-encoding-eval}.

\section{Branching order}
\label{sec:branching-order}
%TODO nossum/soos mailing list cite; is it in text?; more references to literature

The most important heuristic in a SAT solver is the decision which unassigned variable to pick next.
A bad order might assign randomly picked values to many variables before some conflict is found and the search tree depth will be quite high.
This in turn leads to an increased solving time.
On the other hand a good heuristic would pick variables in an order that causes many propagations and with an unsatisfiable assignment leads to conflicts quickly.

The branching order is picked by a heuristic in the SAT solver, which does not have additional knowledge about what these variables represent and how they relate to each other.
By extending the input file format and the variable picking algorithm we can provide our own (partial) variable branching order.

\subsection{Implementation}
\label{sec:branching-order-impl}
We added a new input line type to the \emph{DIMACS CNF} file format.
A line in the form

\centerline{\texttt{b $v$ 0}}

\noindent means that variable $v$ should be branched on first.
When multiple such lines are provided the order of branching is the same as the order of these lines in the input file.
Using this we can provide a list of any number of variables in the order we want them to be picked for assignment.

We modified the popular \emph{MiniSat} solver \cite{een2005minisat} to be able to parse and store this list.
Then we modified the selection of next branching candidate to first pick all these variables in the specified order.
Once all have been assigned we fall back to the standard branching order algorithm.

We have also added support for this to our modeling library.
Before the boolean circuit is transformed to a set of CNF clauses and written to a file, the user can specify arbitrary branching order using variables defined in the model of the cryptographic primitive.