\unnumberedchapter{Conclusions}
%\chapter{Conclusions}
We have created a library for modeling various problems as SAT instances that can then be solved with SAT solvers.
While the library is fairly universal we have specifically focused on cryptographic problems such as modeling preimage attacks on hash functions.
To simplify this use case we make use of operator overloading and dynamic typing that allows use our library with existing implementations with minimal changes.

Previous works in this area used handwritten code to generate instances of a specific hash function that were not easily modifiable.
However this allowed them to optimize the resulting instances, reducing the number of variables and clauses required compared to a na\"{\i}ve Tseitin transformation.
We added an option to optimize specific expression to our library and evaluated the effects of those optimizations.

While we found that the optimized instances can lead to smaller instances (in terms of number of variables and clauses) and fewer conflicts, the solving time was not improved in any statistically significant way.
This leads us to conclude that these optimizations are not required and therefore the minimal changes to existing implementations mentioned above are sufficient to create a reasonable instance.

We then modified the MiniSat solver to see if overriding the default branching order heuristic with the help of additional information about the problem structure would lead to speed improvements.
However, same as with previous optimizations, we found that only the number of conflicts was reduced in this way.
From this we conclude that the existing heuristics employed by modern solvers behave reasonably on these instances and therefore using any supported off-the-shelf solver is sufficient.

Our work can provide basis for future research in several ways.
Firstly, while we have focused on preimage attacks on hash functions different problems could be easily modeled using our library, which we release with full source code and several usage samples.

We believe our approach would prove successful in all areas where SAT solvers have been used previously, such as hash function collisions, key recovery for stream ciphers and so on.
Additionally even problems not related to cryptography could benefit from the ease of use of our library.

Secondly, more optimizations of the resulting instance could be implemented and evaluated.
And lastly, the \emph{HashToolkit} command line tool could be extended to support more hash function, attack modes and so on.