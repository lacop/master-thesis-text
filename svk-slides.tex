%\documentclass[12pt]{article}
\documentclass{beamer}
\usetheme{Madrid}
\usecolortheme{seahorse}

\usepackage{fontspec}
\usepackage{polyglossia}
\setdefaultlanguage{english}

\usepackage{tikz}
\usetikzlibrary{calc}

\usepackage{color}
\usepackage{fancyvrb}


\usepackage{amsthm}
\newtheorem{mydef}{Definition}

\newcommand{\bigO}[1]{\ensuremath{\mathcal{O}(#1)}}

%\usepackage{minted}

\usepackage[noend]{algpseudocode} % No explicit "end function" line
\newcommand*\AlgLet[2]{\State #1 $\gets$ #2} % X <- Y assignment

\title[SAT-based preimage attack optimizations]{Evaluation of SAT-based\\ preimage attack optimizations}
\author[Ladislav Pápay]{Ladislav Pápay\\~\\~\\ Supervisor: doc. RNDr. Martin Stanek PhD.}
\date{}

\begin{document}

\frame{\titlepage}

%%%% OUTLINE
%
% - title
% - problem overview - hash preimage
% - existing work / refs
% - goals + library
% - code sample / sha1 comparison
% - expression opt - example with choice fnc
% - sha1 comparison plot
% - gh analysis + sha3 results + conclusion
% - branching order - overview
% - sha3 comparison plot
% - gh analysis + conclusion
% - ? other opts / 
% - summary
% - thanks  + questions? (+ doi/link)
%
% - tseitin translation
% - existing
% - our approach (operator overloading,...), md5,sha1,sha3 done, easy to do more
% - comparison, simpler code
% - problems - (partial) preimage, (partial) collision
% - graphs
% - further experiments - branch order, ...
% - pros/cons - can prove some preimage doesnt exist (unlike bruteforce), much slower though, not parallelizable
% - conclusion/summary
% - questions/thanks

%\begin{frame}
%\frametitle{Problem Introduction}
%\begin{itemize}
%\item 
%\end{itemize}
%\end{frame}

\begin{frame}
\frametitle{Goals}
\begin{itemize}
\item Allow easy modeling of cryptographic primitives as SAT problems
\item Model hash functions used in practice
\item Measure performance of various attacks
\item Evaluate effect of various heuristics and optimizations
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{SAT Modeling}
\begin{itemize}
\item Can think of any cryptographic primitive as a boolean circuit, with input/output bits and boolean operators inbetween
\item This can be converted to CNF using De Morgan's laws
\begin{itemize}
	\item Size will increase exponentially
\end{itemize}
\item Instead we use \textbf{Tseytin transform}
\begin{itemize}
	\item Introduces additional variables for the operators
	\item The resulting formula will be linear in size
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Existing Work}
\begin{description}
\item[SAT-based preimage attacks on SHA-1 (Nossum, 2012)]~\\ Hand-crafted code to generate SHA-1 instances in SAT-solver friendly CNF format. About 1000 lines of code, with functions like \texttt{xor2}, \texttt{xor3} and \texttt{add5}.
\item[Logical Analysis of Hash Functions (Jovanović, Janičić, 2005)]~\\ Based on a C++ library using operator overloading to simplify the code for MD4 and MD5 implementations. However the library code is unpublished.
\item[\parbox{11cm}{A SAT-based preimage analysis of reduced Keccak hash functions (Morawiecki, Srebrny, 2010)}]~\\ Toolkit that translates Verilog code (low-level hardware description language) to CNF. The toolkit is not published.
\end{description}
\end{frame}

\begin{frame}
\frametitle{Our Approach}
\begin{itemize}
\item Python library that provides a custom data type \textit{BitVector}
\begin{itemize}
	\item Behaves in the same way as any integer type
	\item Using operator overloading creates the boolean circuit automatically
\end{itemize}
\item Model can be made with minimal changes to existing implementations of cryptographic primitives
\begin{itemize}
	\item So far implemented MD5, SHA-1 and SHA-3 (Keccak)
\end{itemize}
\item Saves time, less error-prone
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Approach Comparison (SHA-1 round functions)}
\begin{minipage}[t]{.4\textwidth}
\textit{Vegard Nossum, 2012}
{\tiny
\begin{verbatim}
if (i >= 0 && i < 20) {
  for (unsigned int j = 0; j < 32; ++j) {
    clause(-f[j], -b[j], c[j]);
    clause(-f[j], b[j], d[j]);
    clause(-f[j], c[j], d[j]);

    clause(f[j], -b[j], -c[j]);
    clause(f[j], b[j], -d[j]);
    clause(f[j], -c[j], -d[j]);
  }
} else if (i >= 20 && i < 40) {
  xor3(f, b, c, d);
} else if (i >= 40 && i < 60) {
  for (unsigned int j = 0; j < 32; ++j) {
    clause(-f[j], b[j], c[j]);
    clause(-f[j], b[j], d[j]);
    clause(-f[j], c[j], d[j]);

    clause(f[j], -b[j], -c[j]);
    clause(f[j], -b[j], -d[j]);
    clause(f[j], -c[j], -d[j]);
  }
} else if (i >= 60 && i < 80) {
  xor3(f, b, c, d);
}
\end{verbatim}}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\textit{Our Approach}
{\tiny
\begin{verbatim}
if 0 <= i < 20:
  f = (b & c) | (~b & d)
elif 20 <= i < 40:
  f = b ^ c ^ d
elif 40 <= i < 60:
  f = (b & c) | (b & d) | (c & d)
else:
  f = b ^ c ^ d
\end{verbatim}}
\begin{itemize}
\item This is round function only
\item Overall $\approx$100 lines vs. $\approx$25 lines
\end{itemize}
\end{minipage}
\end{frame}

\begin{frame}
\frametitle{Cryptographic Problems}
\begin{itemize}
\item The model generated for some cryptographic primitive can be easily further constrained
\item Examples for hash functions
\begin{itemize}
\item (Partial) Preimage attack
\begin{itemize}
\item Any number of output bits can be set to either \textit{1} or \textit{0}
\item Satisfiable model assignment provides input message with desired hash image
\item Unsatisfiable model means no such message exists
\end{itemize}
\item (Partial) Collision
\begin{itemize}
\item Taking two hash function models with non-identical inputs but with any number of output bits equal
\item Satisfiable model assignment provides two different input messages with hash images that match on specified bits
\end{itemize}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Examples}
\begin{Verbatim}[commandchars=\\\{\}]
$ python3 hashtoolkit.py -h sha1 -l 64 -o '{\color{red}00001111}'
Setting variables...
Generating clauses...
==================[ Problem Statistics ]===================
|  Number of variables:         43232                     |
|  Number of clauses:          175437                     |
===========================================================
conflicts   : 1170       (923 /sec)
decisions   : 27318      (0.00 % random) (21544 /sec)
CPU time    : 1.268 s

SATISFIABLE

Message bytes: b'{\color{red}YZ[o_DtQ}' rounds:  80
sha1 {\color{red}0f}083bf74420893176930c9ffc90e946d91c9fb7
\end{Verbatim}
\end{frame}

\begin{frame}
\frametitle{Evaluation}
\textbf{Example:} SHA-1 8-bit reference preimage, 32-bit message, 7000 samples
\includegraphics[width=\textwidth]{sha1-32bit-8bitref}
\end{frame}

\begin{frame}
\frametitle{Evaluation}
\textbf{Example:} SHA-1 12-bit reference preimage, 32-bit message, 400 samples
\includegraphics[width=\textwidth]{sha1-32bit-12bitref}
\end{frame}

\begin{frame}
\frametitle{Heuristics}
\begin{itemize}
\item SAT solvers use various heuristics to pick the next branching variable
\item Extended CryptoMiniSAT to allow custom branching order
\item Tried some order restrictions, more to do
\begin{itemize}
\item Every round variable, in forward or reverse round order
\item Same, but only selected rounds
\item Same, but only selected few round variable
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Branching order}
\textbf{Example:} SHA-1, 20 rounds, 32-bit message with 8-bit preimage\\~\\
\begin{center}
\begin{tabular}{l|c|c}
Order & Time [s] & Conflicts \\ \hline
--- & 0.96 & 9755 \\ \hline
20 & 0.94 & 9755 \\
20, 19 & 0.97 & 9755 \\
20, 19, 18 & 17.35 & 71197 \\ \hline
1 & 0.35 & 1062 \\
2 & 0.35 & 1062 \\
1, 2 & 0.33 & 1062 \\
1, 2, 3 & 0.29 & 927 \\
1, 2, 3, 4 & 0.28 & 185 \\
1, 4 & 0.24 & 119
\end{tabular}
\end{center}
\end{frame}

\begin{frame}
\frametitle{Conclusions}
\begin{itemize}
\item Simple to use library for fast and easy modeling of cryptographic primitives
\item Multiple implemented hash functions with (partial) preimage and collision attacks
\end{itemize}
\end{frame}

\begin{frame}
\begin{center}
Questions?
\end{center}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%% OLD %%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%
%% OUTLINE
%%
%% - cryptominisat
%%   - contacted
%% - graphviz output
%%   - conflicts
%%     - dpll conflict recap
%%   - unedited - pretty useless
%%   - annotated
%%   - show in xdot not just static image
%% - xor clauses
%%   - gaussian elimination
%%   - flag/option to toggle
%%   - cms limitation
%% - future
%%   - optimizations, xor, ...
%%   - annotate clauses
%%   - variable ordering
%
%\begin{frame}
%\frametitle{CryptoMiniSAT}
%\begin{itemize}
%\item Extending SAT Solvers to Cryptographic Problems (Soos et al., 2009)
%\begin{itemize}
%	\item Previous presentation\dots
%	\item Support for XOR clauses
%	\item Visualizing conflicts
%\end{itemize}
%\end{itemize}
%\end{frame}
%
%\begin{frame}
%\frametitle{XOR clauses}
%\begin{itemize}
%\item Instead of $2^n$ clauses for $n$-ary XOR only one clause
%\begin{itemize}
%	\item \texttt{-A X Y Z 0\\A -X Y Z 0\\A X -Y Z 0\\...\\-A -X -Y -Z 0}\\~\\
%	\item \texttt{x A X Y Z 0}
%\end{itemize}
%\item The solver can use more efficient heuristics, gaussian elimination, \dots
%\end{itemize}
%\end{frame}
%
%\begin{frame}
%\frametitle{XOR clauses}
%\begin{itemize}
%\item Supported by CryptoMiniSAT
%\item Supported by our tool when converting model to CNF file
%\item But CryptoMiniSAT has internal variable number limit, after which it turns off XOR features
%\begin{itemize}
%	\item Even for small SHA-1 instances exceeded
%	\item Possible solutions:
%	\begin{itemize}
%		\item Switch on only for specific uses
%		\item Combine with XOR merging optimization
%	\end{itemize}
%\end{itemize}
%\end{itemize}
%\end{frame}
%
%\begin{frame}
%\frametitle{Conflict visualization}
%\begin{itemize}
%\item CDCL - Conflict-Driven Clause Learning
%\begin{itemize}
%	\item \textit{Decision} and \textit{forced} (from DPLL rules) assignments
%	\item When conflict (unsatisfiable clause) is found, build \textit{learnt} clause from decision assignments
%	\item Jump in backtracking to first time a conflict variable was assigned
%\end{itemize}
%\end{itemize}
%\end{frame}
%
%\begin{frame}
%\frametitle{Conflict visualization}
%\begin{itemize}
%\item Supported in some CryptoMiniSAT versions
%\item Very slow
%\item Generates Graphviz files for every conflict
%\end{itemize}
%\end{frame}
%
%\begin{frame}
%\begin{center}
%Demo 1\\
%Simple conflict graph\\
%~\\
%{\tiny \texttt{confl1.dot}}
%\end{center}
%\end{frame}
%
%\begin{frame}
%\begin{center}
%Demo 2\\
%Raw CryptoMiniSAT output\\
%SHA-1, 80 rounds, 8bit message, no restrictions
%~\\
%{\tiny \texttt{confl19.dot}, \texttt{confl60.dot}}
%\end{center}
%\end{frame}
%
%\begin{frame}
%\frametitle{Annotation}
%\begin{itemize}
%\item Not very useful/readable on its own
%\item Displays variables just as numbers
%\item Added annotations
%\begin{itemize}
%	\item Can easily add annotations to variables with the library
%	\item Automatically annotates operators
%	\item After solving adds annotations to the output graphs
%\end{itemize}
%\end{itemize}
%\end{frame}
%
%\begin{frame}
%\begin{center}
%Demo 3\\
%Annotated output\\
%SHA-1, 80 rounds, 8bit message, no restrictions
%~\\
%{\tiny \texttt{confl1.dot}, \texttt{confl19.dot}, \texttt{confl60.dot}}
%\end{center}
%\end{frame}
%
%\begin{frame}
%\frametitle{Next steps}
%\begin{itemize}
%\item Annotate clauses as well
%\begin{itemize}
%	\item For now just list of variables
%	\item But could say things like "ADD carry bit \#4"
%\end{itemize}
%\item Experiment with XOR clauses and optimizations
%\item Experiment with variable ordering
%\begin{itemize}
%	\item Force some (partial) order in which the SAT solver assigns values to variables
%	\item Supported by CryptoMiniSAT, but different version - need to port
%\end{itemize}
%\end{itemize}
%\end{frame}
%
%%\begin{frame}
%%\frametitle{Introduction}
%%\begin{itemize}
%%\item SAT solvers - modeling problems as CNF formulas
%%\begin{itemize}
%%\item Heuristics to solve, run time unpredictable
%%\end{itemize}
%%\item Cryptography problems
%%\begin{itemize}
%%\item Hash functions - (partial) pre-image attack
%%\end{itemize}
%%\item Goals
%%\begin{itemize}
%%\item Way to model cryptography primitives for SAT solvers
%%\item Evaluate attack performance
%%\end{itemize}
%%\end{itemize}
%%\end{frame}
%%
%%\begin{frame}
%%\frametitle{Modeling}
%%Existing work
%%\begin{itemize}
%%\item SAT-based preimage attacks on SHA-1 (Vegard Nossum, 2012) - written in C, hard to modify/extend
%%\item Logical Analysis of Hash Functions (Jovanović, Janičić 2005) - operator overloading, code not published
%%\end{itemize}
%%Our implementation
%%\begin{itemize}
%%\item Operator overloading in Python to create initial expression tree
%%\item Optimizations to reduce tree size
%%\item Tseitin transformation to generate CNF formula for SAT
%%\end{itemize}
%%\end{frame}
%%
%%\begin{frame}[fragile]
%%\frametitle{Comparison - SHA1 compression function}
%%Standard Python implementation
%%\begin{verbatim}
%%F = fs[i//20](A, B, C, D, E)
%%k = K[i//20]
%%T = (leftrotate(A, 5) + F + E + k + W[i]) & 0xFFFFFFFF
%%A, B, C, D , E = T, A, leftrotate(B, 30), C, D
%%\end{verbatim}
%%
%%Using SAT modeling library
%%\begin{verbatim}
%%F = fs[i//20](A, B, C, D, E)
%%k = Kvec[i//20]
%%T = CyclicLeftShift(A, 5) + F + E + k + Mvec[i]
%%A, B, C, D, E = T, A, CyclicLeftShift(B, 30), C, D
%%\end{verbatim}
%%\end{frame}
%%
%%\begin{frame}[fragile]
%%\frametitle{Comparison - SHA1 compression function}
%%Standart implementation - round functions and constants
%%\begin{verbatim}
%%fs = [lambda a,b,c,d,e: (b & c) | (~b & d),
%%      lambda a,b,c,d,e: b ^ c ^ d,
%%      lambda a,b,c,d,e: (b & c) | (b & d) | (c & d),
%%      lambda a,b,c,d,e: b ^ c ^ d]
%%K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6]
%%\end{verbatim}
%%Function array \texttt{fs} is identical for SAT modeling, constants have to be converted:
%%\begin{verbatim}
%%Kvec = [intToVector(x) for x in K]
%%\end{verbatim}
%%\end{frame}
%%
%%\begin{frame}[fragile]
%%\frametitle{Comparison - SHA1 compression function}
%%SAT-based preimage attacks on SHA-1 (Vegard Nossum, 2012)
%%\begin{verbatim}
%%rotl(prev_a, a[i + 4], 5);
%%rotl(b, a[i + 3], 0);
%%rotl(c, a[i + 2], 30);
%%rotl(d, a[i + 1], 30);
%%rotl(e, a[i + 0], 30);
%%new_vars(format("f[$]", i), f, 32);
%%
%%if (i >= 0 && i < 20) { ... }
%%else if (i >= 20 && i < 40) { ... }
%%else if (i >= 40 && i < 60) { ... }
%%else if (i >= 60 && i < 80) { ... }
%%
%%add5(format("a[$]", i + 5), a[i + 5], prev_a, 
%%     f, e, k[i / 20], w[i]);
%%\end{verbatim}
%%\end{frame}
%%
%%\begin{frame}[fragile]
%%\frametitle{Comparison - SHA1 compression function}
%%SAT-based preimage attacks on SHA-1 (Vegard Nossum, 2012)
%%\begin{verbatim}
%%if (i >= 0 && i < 20) {
%%    for (unsigned int j = 0; j < 32; ++j) {
%%        clause(-f[j], -b[j], c[j]);
%%        clause(-f[j], b[j], d[j]);
%%        clause(-f[j], c[j], d[j]);
%%		
%%        clause(f[j], -b[j], -c[j]);
%%        clause(f[j], b[j], -d[j]);
%%        clause(f[j], -c[j], -d[j]);
%%    }
%%}
%%\end{verbatim}
%%\end{frame}
%%
%%\begin{frame}
%%\frametitle{Hash tool}
%%Simple CLI to generate, solve and verify a custom instance.
%%
%%Can customize:
%%\begin{itemize}
%%\item Hash function (SHA-1, MD5, ...)
%%\item Number of rounds
%%\item Input message length and value
%%\item Output hash value
%%\end{itemize}
%%\end{frame}
%%
%%\begin{frame}[fragile]
%%\frametitle{Examples}
%%\begin{verbatim}
%%$ python3 hashtoolkit.py -h sha1 -l 64 -r 80 -o '11111111'
%%...
%%CPU time              : 1.196 s
%%SATISFIABLE
%%...
%%Message: b'-Y[\x1c\x02r\x95*'
%%Digest: ffdc71cf25e4b48f67b0cc39d829e5d422b7358c
%%\end{verbatim}
%%\end{frame}
%%
%%\begin{frame}[fragile]
%%\frametitle{Examples}
%%\begin{verbatim}
%%$ python3 hashtoolkit.py -h sha1 -l 64 -r 80 -o '1111????1111'               
%%...
%%CPU time              : 1.036 s
%%SATISFIABLE
%%...
%%Message: b'\xf5\x1d\x8f\xb5q\x04r\x0c'
%%Digest: f1ff58764bbc581c95b36077d828c578b20aa9b9
%%\end{verbatim}
%%\end{frame}
%%
%%\begin{frame}[fragile]
%%\frametitle{Examples}
%%\begin{verbatim}
%%$ python3 hashtoolkit.py -h sha1 -l 64 -r 80 -o '1111????1111'
%%  -i '01??????01??????...'             
%%...
%%CPU time              : 0.56 s
%%SATISFIABLE
%%...
%%Message: b'PadtBg'
%%Digest: f8f1334c98ae774062b448c68c3b5f651fbc7e7d
%%\end{verbatim}
%%\end{frame}
%%
%%%\begin{frame}
%%%\frametitle{SHA-1, 64bit input, 4bit fixed output}
%%%\resizebox{\textwidth}{0.8\textheight}{\input{plots/sha1-input64-out4fixed-rounds.tex}}
%%%\end{frame}
%%%
%%%\begin{frame}
%%%\frametitle{SHA-1, 64bit input, 8bit fixed output}
%%%\resizebox{\textwidth}{0.8\textheight}{\input{plots/sha1-input64-out8fixed-rounds.tex}}
%%%\end{frame}
%%
%%
%%\begin{frame}
%%\frametitle{Optimizations}
%%\begin{itemize}
%%\item Works great for reduced number of rounds
%%\item Gets slow very quickly after that
%%\item Some of that is because of inefficient circuits
%%\end{itemize}
%%\end{frame}
%%
%%\begin{frame}
%%\frametitle{Optimizations}
%%\begin{itemize}
%%\item Merge binary operators into n-ary
%%	\begin{itemize}
%%	\item AND, OR
%%	\item XOR - maximum arity
%%	\item Implemented, need to measure and tweak settings
%%	\end{itemize}
%%\item Optimize common expressions
%%	\begin{itemize}
%%	\item For example round functions like $(b \land c) \lor (\lnot b \land d)$
%%	\item Now needs 7 variables (3 extra), 11 clauses
%%	\item Can be done with no extra variables and 6 clauses
%%	\item Use \emph{espresso} heuristic minimizer
%%	\end{itemize}
%%\item Other miscellaneous optimizations
%%	\begin{itemize}
%%	\item Negation
%%	\item Repeated operands, tautologies, ...
%%	\end{itemize}
%%\end{itemize}
%%\end{frame}
%%
%%\begin{frame}
%%\frametitle{Extending SAT solvers}
%%\begin{itemize}
%%\item Understand what makes an instance hard/slow
%%\item Extend SAT solver to get information about solving
%%\item Visualizing SAT Instances and Runs of the DPLL Algorithm (Sinz, 2006) - next slides
%%\item Extending SAT Solvers to Cryptographic Problems (Soos et al., 2009)
%%\end{itemize}
%%\end{frame}
%%
%%%\begin{frame}
%%%\frametitle{SHA-1, 8 bit input message, 0 rounds}
%%%\begin{tikzpicture}[remember picture,overlay]
%%%	\node[at=(current page.center)] {
%%%		\includegraphics[height=0.8\textheight]{shal8r0.png}
%%%	};
%%%\end{tikzpicture}
%%%\end{frame}
%%%\begin{frame}
%%%\frametitle{SHA-1, 8 bit input message, 1 round}
%%%\begin{tikzpicture}[remember picture,overlay]
%%%	\node[at=(current page.center)] {
%%%		\includegraphics[height=0.8\textheight]{shal8r1.png}
%%%	};
%%%\end{tikzpicture}
%%%\end{frame}
%%%\begin{frame}
%%%\frametitle{SHA-1, 8 bit input message, 5 rounds}
%%%\begin{tikzpicture}[remember picture,overlay]
%%%	\node[at=(current page.center)] {
%%%		\includegraphics[height=0.8\textheight]{shal8r5.png}
%%%	};
%%%\end{tikzpicture}
%%%\end{frame}
%%%\begin{frame}
%%%\frametitle{SHA-1, 8 bit input message, 10 rounds}
%%%\begin{tikzpicture}[remember picture,overlay]
%%%	\node[at=(current page.center)] {
%%%		\includegraphics[height=0.8\textheight]{shal8r10.png}
%%%	};
%%%\end{tikzpicture}
%%%\end{frame}
%%%\begin{frame}
%%%\frametitle{SHA-1, 8 bit input message, 20 rounds}
%%%\begin{tikzpicture}[remember picture,overlay]
%%%	\node[at=(current page.center)] {
%%%		\includegraphics[height=0.8\textheight]{shal8r20.png}
%%%	};
%%%\end{tikzpicture}
%%%\end{frame}
%%
%%
%%\begin{frame}
%%\frametitle{Current/future work}
%%\begin{itemize}
%%\item Automate attack timing with varying parameters
%%\begin{itemize}
%%\item Store all times, remove outliers, ...
%%\item Generate plots
%%\end{itemize}
%%\item Extend SAT solver(s) to gather some statistics
%%\item Experiment with SAT solvers supporting XOR clauses, addition, ...
%%\end{itemize}
%%\end{frame}
%%
%%%SLIDY
%%%-----
%%%
%%%* Title/...
%%%? SAT intro
%%%
%%%* Modelovanie hash fnc
%%%? kompresne funkcie, ...
%%%* SHA1, ine prace?
%%%
%%%* Moj tool
%%%* operator overloading
%%%* ukazka kodu pre rozne hash fnc, porovnanie mojho a orig
%%%* porovnanie mojho a sha1 thesis
%%%
%%%* optimalizacie
%%%
%%%? future work
%%%
%%%
%%
%
%
%%\section{Intro}
%%\begin{frame}
%%\frametitle{Úvod}
%%\begin{itemize}
%%	\item Cieľ: generovanie kľúčov z užívateľských hesiel
%%	\item Motivácia\hfill
%%	\begin{itemize}
%%		\item Ochrana hesiel v prípade kompromitácie serveru
%%		\item Tvorba kľúčov dostatočnej dĺžky pre šifrovanie
%%	\end{itemize}
%%	\item Online vs. offline útok -- pre online vieme robit rate limiting
%%	\item Chceme pre-image odolnosť -- najlepší útok je bruteforce hesiel
%%\end{itemize}
%%\end{frame}
%%
%%\begin{frame}
%%\frametitle{Bruteforce}
%%\begin{itemize}
%%	\item Heslá sú väčšinou dosť slabé
%%	\item Priemerná entropia: 37 bitov (NYT), 42 (PayPal), 51 (OWA, pravidlá)
%%	\item Zvýšime zložitosť bruteforce útoku spomalením KDF
%%\end{itemize}
%%\end{frame}
%%
%%\begin{frame}
%%\frametitle{História}
%%\begin{itemize}
%%	\item Stará myšlienka
%%	\item \textbf{crypt} 1976 -- 25 iterácií DES, v tej dobe 4 h/s
%%	\item \textbf{bcrypt} 1999 -- variabilná cena výpočtu, default root v tej dobe ~8 h/s (ale crypt už 200 kh/s)
%%	\item \textbf{PBKDF2} 2000 -- podobné ako bcrypt
%%	\item \textbf{scrypt} 2009 -- variabilná cena výpočtu a použitá pamäť
%%\end{itemize}
%%\end{frame}
%%
%%{
%%\setbeamertemplate{navigation symbols}{}
%%\begin{frame}[plain]
%%	\begin{tikzpicture}[remember picture,overlay]
%%		\node[at=(current page.center)] {
%%			\includegraphics[width=\paperwidth]{lin-1.png}
%%		};
%%    \end{tikzpicture}
%%\end{frame}
%%\begin{frame}[plain]
%%	\begin{tikzpicture}[remember picture,overlay]
%%		\node at ($(current page.center)+(0,3)$) {
%%			\includegraphics[width=\paperwidth]{lin-2.png}
%%		};
%%		\node at ($(current page.center)+(0,0.5)$) {
%%			\includegraphics[width=\paperwidth]{lin-3.png}
%%		};
%%		\node at ($(current page.center)+(0,-2)$) {
%%			\includegraphics[width=\paperwidth]{lin-4.png}
%%		};
%%    \end{tikzpicture}
%%\end{frame}
%%\begin{frame}[plain]
%%	\begin{tikzpicture}[remember picture,overlay]
%%		\node at ($(current page.center)+(0,3.5)$) {
%%			\includegraphics[width=\paperwidth]{lin-5.png}
%%		};
%%		\node at ($(current page.center)+(0,-1)$) {
%%			\includegraphics[width=\paperwidth]{lin-6.png}
%%		};
%%    \end{tikzpicture}
%%\end{frame}
%%\begin{frame}[plain]
%%	\begin{tikzpicture}[remember picture,overlay]
%%		\node[at=(current page.center)] {
%%			\includegraphics[width=\paperwidth]{lin-7.png}
%%		};
%%    \end{tikzpicture}
%%\end{frame}
%%\begin{frame}[plain]
%%	\begin{tikzpicture}[remember picture,overlay]
%%		\node[at=(current page.center)] {
%%			\includegraphics[width=\paperwidth]{lin-8.png}
%%		};
%%    \end{tikzpicture}
%%\end{frame}
%%\begin{frame}[plain]
%%	\begin{tikzpicture}[remember picture,overlay]
%%		\node at ($(current page.center)+(0,3)$) {
%%			\includegraphics[width=\paperwidth]{vyv-1.png}
%%		};
%%		\only<2>{\node at ($(current page.center)+(0,-3)$) {
%%			\includegraphics[width=\paperwidth]{vyv-2.png}
%%		};}
%%    \end{tikzpicture}
%%\end{frame}
%%}
%%
%%
%%\section{crypt}
%%\begin{frame}
%%\frametitle{crypt}
%%\begin{itemize}
%%	\item 8 znakové heslo, z každého znaku len spodných 7 bitov $\to$ 56 bitový kľúč, ak je heslo kratšie doplní sa o nulové bity
%%	\item 12 bitový salt -- použije sa na permutáciu E-boxu\\
%%	\begin{itemize}
%%		\item HW bruteforcer (EFF Deep Crack 1998, 56 hodín) nefunguje
%%	\end{itemize}
%%	\item 64 bitová sprava z núl je 25 krát zašifrovaná DESom
%%	\item Výsledok je 64 bitový ciphertext + 12 bitový salt = 13 printable ASCII znakov
%%\end{itemize}
%%\end{frame}
%%
%%\begin{frame}
%%\frametitle{Nedostatky}
%%\begin{itemize}
%%	\item Obmedzená dĺžka hesla
%%	\item Krátky salt
%%	\item V tej dobe pomalé ale konštantne, výpočtová sila narastá
%%\end{itemize}
%%\end{frame}
%%
%%\begin{frame}
%%\frametitle{MD5 crypt}
%%\begin{itemize}
%%	\item Dlhšie heslá, dlhší salt
%%	\item Obchádzanie zákazu exportu kryptografie z USA
%%	\item Spätne "kompatibilné" s crypt-om: vysledok začína \texttt{\$1\$}
%%	\item Ale stále konštantná cena výpočtu
%%\end{itemize}
%%\end{frame}
%%
%%\section{bcrypt}
%%\begin{frame}
%%\frametitle{bcrypt}
%%\begin{itemize}
%%	\item Niels Provos, David Mazières (1999, OpenBSD)
%%	\item Cena výpočtu je nastaviteľná\\
%%	\begin{itemize}
%%		\item Môžeme postupne zvyšovať pri prihlasovaní užívateľov
%%		\item Čas prihlásenia zostane konštantný, útok sa nebude zľahčovať
%%	\end{itemize}
%%\end{itemize}
%%\end{frame}
%%
%%\subsection{eksblowfish}
%%\begin{frame}
%%\frametitle{eksblowfish}
%%\begin{columns}[T]
%%	\begin{column}{.5\textwidth}
%%		\begin{itemize}
%%			\item Expensive Key Schedule Blowfish
%%			\item Blowfish (Schneier, 1993)\\
%%			\begin{itemize}
%%				\item 64 bitová bloková šifra
%%				\item 16 kolová Feistelovská konštrukcia
%%				\item 448 bitový kľúč
%%				\item 32 bitové podkľúče $P_1, \dots, P_{18}$
%%				\item 4$\times$256 32-bitové S-boxy
%%			\end{itemize}
%%			\item Šifrovanie je identické
%%			\item Setup ma variabilnú cenu
%%			\item Heslo je max 56 bajtov
%%		\end{itemize}
%%	\end{column}
%%	\begin{column}{.5\textwidth}\raggedleft
%%		\includegraphics[width=0.55\paperwidth]{figure-blowfish.pdf}
%%	\end{column}
%%\end{columns}
%%\end{frame}
%%
%%\begin{frame}
%%\frametitle{EksBlowfishSetup}
%%\begin{algorithmic}
%%	\Function{EksBlowfishSetup}{cost, salt, key}
%%	\AlgLet{state}{InitState()}
%%	\AlgLet{state}{ExpandKey(state, salt, key)}
%%	\For{$2^{cost}$}
%%		\AlgLet{state}{ExpandKey(state, 0, salt)}
%%		\AlgLet{state}{ExpandKey(state, 0, key)}
%%	\EndFor
%%	\State \Return{state}
%%	\EndFunction
%%\end{algorithmic}
%%\end{frame}
%%
%%\begin{frame}
%%\frametitle{EksBlowfishSetup}
%%\begin{description}
%%	\item[InitState] Naplní S-boxy a $P_1, \dots, P_{18}$ ciframi $\pi$
%%	\item[ExpandKey](state, salt, key)\hfill salt má 128 bitov\\
%%		\only<1>{Najskôr priXORuje kľúč k podkľúčom $P_i$ (ak je kľuč krátky tak sa cyklicky opakuje).\\
%%		Následne zašifruje prvých 64 bitov saltu pomocou aktuálneho stavu. Výsledok bude $P_1$ a $P_2$. PriXORuje sa tiež k druhej polovici saltu a to sa zašifruje pomocou nového stavu. Výsledok bude $P_3$ a $P_4$.\\
%%		Toto sa opakuje kým sa nezmení celé $P_i$ a všetky S-boxy.}
%%		%\only<1>{\hfill\\\hfill\\\hfill\\\hfill\\\hfill\\\hfill\\\hfill\\\hfill\\\hfill\\}
%%	\only<2->{
%%	\item[]
%%	\item[ExpandKey](state, 0, key)
%%	\item[ExpandKey](state, 0, salt)\hfill\\
%%		Pre salt zložený z 128 bitov 0 je toto ekvivalentné štandardnému Blowfish key schedule.\\
%%		Vďaka tomu môžeme pre všetky volania ExpandKey okrem prvého použiť existujúce implementácie Blowfish KS.
%%		\hfill\\\hfill\\
%%	}
%%\end{description}
%%\end{frame}
%%
%%\subsection{bcrypt}
%%\begin{frame}
%%\frametitle{bcrypt}
%%\begin{algorithmic}
%%	\Function{bcrypt}{cost, salt, password}
%%	\AlgLet{state}{EksBlowfishSetup(cost, salt, password)}
%%	\AlgLet{ctext}{"OrpheanBeholderScryDoubt"}
%%	\For{$64$}
%%		\AlgLet{ctext}{EncryptECB(state, ctext)}
%%	\EndFor
%%	\State \Return{cost || salt || ctext}
%%	\EndFunction
%%\end{algorithmic}
%%\end{frame}
%%
%%\section{PBKDF2}
%%\begin{frame}
%%\frametitle{PBKDF2}
%%\begin{itemize}
%%	\item RFC 2898 PKCS \#5: Password-Based Cryptography Specification (RSA Laboratories, 2000)
%%	\item $PBKDF2_{PRF}(password, salt, cost, dkLen)$
%%	\item Výstup $DK = T_1 || T_2 || \cdots || T_{\frac{dkLen}{hLen}}$\\
%%	\begin{itemize}
%%		\item $T_i = F(password, salt, cost, i)$\hfil\\\hfill
%%		\item $F(password, salt, cost, i) = U_1 \oplus U_2 \oplus \cdots \oplus U_{cost}$\hfill\\\hfill
%%		\item $U_1 = PRF(password, salt ~||~ i)$
%%		\item $U_{i+1} = PRF(password, U_{i})$
%%	\end{itemize}
%%	\item Pre PRF napríklad HMAC\_SHA-256 stačí rádovo 512 bitov pamäte, bcrypt potrebuje $4\times256\times 32 = 32768$ bitov
%%\end{itemize}
%%\end{frame}
%%
%%\section{Paralelizmus}
%%\begin{frame}
%%\frametitle{Paralelizmus}
%%\begin{itemize}
%%	\item Zvyšovaním parametru cost pri bcrypt-e môžeme zachovať čas prihlasovania / dešifrovania rovnaký pri náraste rýchlosti HW
%%	\item Počet operácií, ktoré musí útočník vykonať narastá
%%	\item Ale bruteforce je triviálne paralelizovateľný, takže čas útoku je možné podstatne znížiť oproti sekvenčnému algoritmu
%%	\item Chceme náročnosť merať v iných jednotkách -- dollar-seconds
%%\end{itemize}
%%\end{frame}
%%
%%\begin{frame}
%%\begin{itemize}
%%	\item Ako zvýšiť náročnosť útoku pomocou špecializovaného HW (FPGA, ASIC)?
%%	\item Okrem parametrizácie počtu operácií budeme parametrizovať aj použitú pamäť
%%	\item Pamäť je drahá, zaberá veľkú časť silikónu -- čím viac jej použijeme, tým menej paralelných výpočtov môže prebiehať na jednom čipe
%%\end{itemize}
%%\end{frame}
%%
%%\begin{frame}
%%\frametitle{Memory-hard}
%%\begin{mydef}
%%A \emph{memory-hard} algorithm on a Random Access Machine is an algorithm which uses $S(n)$ space and $T(n)$ operations, where $S(n) \in \Omega(T(n)^{1−\epsilon})$.
%%\end{mydef}
%%\begin{itemize}
%%	\item HEKS (Reinolds, 1999)
%%\end{itemize}
%%\begin{mydef}
%%A sequential memory-hard function is a function which
%%\begin{enumerate}
%%\item can be computed by a memory-hard algorithm on a Random Access Machine
%%in $T(n)$ operations; and
%%\item cannot be computed on a Parallel Random Access Machine with $S^∗(n)$
%%processors and $S^∗(n)$ space in expected time $T^∗(n)$ where $S^∗(n)T^∗(n) =
%%\bigO{T(n)^{2−x}}$ for any $x > 0$.
%%\end{enumerate}
%%\end{mydef}
%%\end{frame}
%%
%%\subsection{ROMix}
%%\begin{frame}
%%\frametitle{ROMix}
%%\begin{itemize}
%%	\item Potrebujeme nejakú \emph{sequential memory-hard} funkciu
%%	\item $ROMix_H : \{0,1\}^k \times \{0,\dots,2^{\frac{k}{8}}-1\} \to \{0,1\}^k$
%%	\item Parametre:\\
%%	\begin{description}
%%		\item[H] hash funkcia
%%		\item[k] dĺžka vstupu/výstupu
%%		\item[Integrify] bijekcia z $\{0,1\}^k$ do $\{0,\dots,2^k-1\}$
%%	\end{description}
%%	\item Vstup:\\
%%	\begin{description}
%%		\item[B] vstup dĺžky $k$ bitov
%%		\item[N] \emph{work metric}, $N < 2^{\frac{k}{8}}$
%%	\end{description}
%%	\item Výstup:\\
%%	\begin{description}
%%		\item[B'] výstup dĺžky $k$ bitov
%%	\end{description}
%%\end{itemize}
%%\end{frame}
%%
%%\begin{frame}
%%\begin{itemize}
%%	\item $H$ náhodné orákulum
%%	\item Hodnoty $H^{(0)}(B), H^{(1)}(B), \dots, H^{(N-1)}(B)$ sú rôzne
%%	\item Potom je $ROMix_H$ trieda \emph{sequential memory-hard} funkcií
%%	\item Myšlienka dôkazu:\\
%%	\begin{itemize}
%%		\item Bez $H^{(x-1)}(B)$ nevieme vypočítať $H^{(x)}(B)$
%%		\item Ak máme menej pamäte tak si nemôžeme pamätať všetky $H^{(i)}(B)$ ale musíme ich počítať vždy znovu
%%	\end{itemize}
%%\end{itemize}
%%\end{frame}
%%
%%\subsection{SMix}
%%\begin{frame}
%%\frametitle{SMix}
%%\begin{itemize}
%%	\item Náhodne orákulum nemáme
%%	\item Chceme nejakú prakticky použiteľnú funkciu H s veľkým blokom kvôli rýchlosti
%%	\item Vlastnosti, ktoré chceme od $H$:
%%	\begin{itemize}
%%		\item Výstup rovnomerne distribuovaný v $\{0,1\}^k$
%%		\item Nemožnosť rýchlo iterovať ani s veľa paralelnými kópiami orákula
%%		\item Nemožnosť spočítať $Integrify(H(x))$ omnoho rýchlejšie ako $H(x)$
%%		\item Pomer $k$ : počet operácií čo najväčší (HW optimalizácia)
%%		\item Nie viac interného paralelizmu ako SW implementácia
%%	\end{itemize}
%%\end{itemize}
%%\end{frame}
%%
%%\begin{frame}
%%\begin{itemize}
%%	\item $BlockMix_{H,r} : \{0,1\}^{2r \cdot k} \to \{0,1\}^{2r \cdot k}$
%%	\begin{itemize}
%%		\item $BlockMix$ spĺňa požadované vlastnosti
%%	\end{itemize}
%%	\item Pre $H$ použijeme Salsa20/8 (Bernstein, 2007)\\
%%	\begin{itemize}
%%		\item Prúdová šifra, 256 bitový kľúč, 512 bitový stav/výstup
%%		\item Použijeme len 8 z 20 kôl ako PRF
%%		\item Najlepší útok je na 8 z 20 kôl, $2^{31}$ keystream pairs, $2^{251}$ operácií
%%	\end{itemize}
%%	\item $SMix_r : \{0,1\}^{1024r} \times \{0, \dots, 2^{64}-1\} \to \{0,1\}^{1024r}$
%%	\item $SMix_r(B, N) = ROMix_{BlockMix_{Salsa20/8, r}} (B, N)$\\
%%	\begin{itemize}
%%		\item $Integrify(B_0 \dots B_{2r-1}) = B_{2r-1}$
%%	\end{itemize}
%%	\item $SMix_r(B, N)$ ide vypočítať použitím $1024Nr + \bigO{r}$ bitov pamäte a $4Nr$ iterácií PRF Salsa20/8.
%%\end{itemize}
%%\end{frame}
%%
%%\section{scrypt}
%%\begin{frame}
%%\frametitle{Key derivation function}
%%\begin{itemize}
%%	\item $MFcrypt_{PRF, MF}(P, S, N, p, dkLen)$ \\
%%	\begin{description}
%%		\item[PRF] Pseudonáhodná funkcia s výstupm dĺžky $hLen$ bajtov
%%		\item[MF] Sequential memory-hard funkcia z $\mathbb{Z}^{MFLen}_{256} \times \mathbb{N}$ do $\mathbb{Z}^{MFLen}_{256}$ kde $MFLen$ je dĺžka blokov $MF$ v bajtoch		
%%		\item[P, S] Heslo a salt
%%		\item[N] CPU/memory cost
%%		\item[p] Paralelizmus
%%		\item[dkLen] Požadovaná dĺžka výstupu
%%	\end{description}
%%	\item \emph{Sequential memory-hard} ak aj $MF$ je
%%\end{itemize}
%%\end{frame}
%%
%%\subsection{Hurá!}
%%\begin{frame}
%%\begin{center}
%%$scrypt(P, S, N, r, p, dkLen) = MFcrypt_{HMAC\_SHA-256, SMix_r}(P, S, N, p, dkLen)$
%%\end{center}
%%\end{frame}
%%
%%\section{Porovnanie}
%%\begin{frame}
%%\frametitle{Porovnanie}
%%\begin{itemize}
%%	\item Jednotky sú dolár-roky = cena HW čo by po roku mal 50\% šancu na úspech
%%	\item Počíta len cenu za plochu silikónu
%%	\item Zvyšná elektronika, napájanie a chladenie by bolo $\approx 10$-krát viac
%%	\item Ale staré údaje -- lepší návrh obvodov a lepší výrobný proces môže znížiť $\approx 10$ násobne
%%\end{itemize}
%%\end{frame}
%%
%%\begin{frame}
%%\frametitle{Príklady hesiel}
%%\begin{description}
%%	\item[6 lowercase] \texttt{sfgroy}
%%	\item[8 lowercase] \texttt{ksuvnwyf}
%%	\item[8 printable] \texttt{6,uh3y[a}
%%	\item[10 printable] \texttt{H.*W8Jz\&r3}
%%	\item[40 string] \texttt{This is a 40-character string of English}
%%	\item[80 string] \texttt{This is an 80-character phrase which you probably won’t be able to crack easily.}
%%\end{description}
%%\end{frame}
%%
%%\begin{frame}
%%	\begin{tikzpicture}[remember picture,overlay]
%%		\node[at=(current page.center)] {
%%			\includegraphics[width=\paperwidth]{fig-comparison.png}
%%		};
%%    \end{tikzpicture}
%%\end{frame}
%%
%%\section{Literatúra}
%%\begin{frame}
%%\frametitle{Literatúra}
%%\begin{itemize}
%%\item Provos, N., Mazieres, D. (1999, June). A Future-Adaptable Password Scheme. In USENIX Annual Technical Conference, FREENIX Track (pp. 81-91).
%%\item Percival, C. (2009). Stronger key derivation via sequential memory-hard functions.
%%\item Kaliski, B. (2000). RFC 2898; PKCS\# 5: Password-Based Cryptography Specification Version 2.0.
%%\end{itemize}
%%\end{frame}

\end{document}
