%\chapter{Modeling library}
\chapter{Modeling library}
%TODO after SVK change section to chapters, subsections to sections etc (commands and text references)

The works mentioned in previous chapter created their models for various cryptographic problems mostly by hand.
While the results obtained are interesting, they are hard to reproduce by others.
Also this approach does not help to solve similar problems (like using a different hash function instead), as a new model would have to be created from scratch.

To address these issues we provide an easy to use and reusable library for modeling SAT instances.
While the library can be used for modeling any problem we specifically focus on making modeling cryptographic problems as simple as possible.
In this chapter we will state our goals for this library, describe its design and inner functionality.
We will also show examples of its use.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Goals}
The main goals of our library are as follows:

~\\
\textbf{Existing implementation reuse:}
In order to simplify the modeling of cryptographic primitives as much as possible we want to allow reuse of existing implementations.
Most commonly used primitives -- such as hash functions, block and stream ciphers and others -- have widely available implementations in all popular programming languages.

The library should therefore allow using these implementations with only minor changes.
In addition to saving time this also makes the modeling less error-prone as we can build upon a well tested implementation.

~\\
\textbf{Output abstraction:}
The library should take care of generating the output in proper format for some SAT solver.
With solvers that support advanced features, such as \emph{XOR} clauses, it should be possible to take advantage of them.

~\\
\textbf{Model parsing:}
After successfully solving the instance with a SAT solver we obtain a model in form of a satisfying variable assignment.
The library should be able to load this model and map the truth assignment back to variables defined by the user.
This makes it easy to extract for example the colliding messages out of the model.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Our approach}
To achieve the goals stated in previous section we take advantage of a technique called \emph{operator overloading}.
This is a feature present in many programming languages.
For our library we have decided to use the \emph{Python} language which also supports it.
Python has the additional advantage that it is very popular and therefore has implementations of virtually all commonly used cryptographic primitives.

\subsection{Operator overloading}
\label{sec:operator-overloading}
As the name suggests, operator overloading allows us to overload (override) existing behavior of operators in some programming language.
While the feature is only \emph{syntactic sugar} (which means it does not allow us to do anything more than would be possible without it; it just simplifies the syntax) it not only greatly increases the readability of the code, but also allows us to reuse existing implementations as we will show.

The reason this feature is useful in our library is that we can change the type of some variables in existing code without having to change anything else.
For example, we can take an implementation of some hash function and change the type of all variables from the built-in integers to our new data type.
Without operator overloading this could would not be possible, since operators such as addition or bit shift would not be defined for our new type by the language.
With operator overloading however we can provide these definitions ourselves.

Our library provides a new data type \emph{BitVector} that supports all the operations as the built-in integer type.
Since Python uses \emph{dynamic typing} it is sufficient to change the types of the constants used by the cryptographic primitive implementation.
All other variables are a result of operations on these constants and will therefore have the proper type.

\subsection{Boolean circuit creation}
The difference between the built-in integer type and \emph{BitVector} is that while the integer variable only holds one given value, our type instead stores how its value can be obtained from other variables.

More specifically, each time an operation is applied to one or more operands (variables of type \emph{BitVector} or constants) the result is another instance of type \emph{BitVector} which stores these operands.  That means that the output of some cryptographic primitive is not a single value but instead a boolean circuit representation. The circuit will form a directed acyclic graph.
%TODO figure of boolean circuit here

\subsection{Instance generation}
Once we have the boolean circuit for a model we can then take this representation and output a SAT instance using the Tseitin transformation described in section \ref{sec:tseitin}.

The order of clauses in the output is irrelevant, however since the circuit forms a DAG we can process it in topological order.
For every node (representing an operator applied to one or more operands) we first assign numbers to all required variables.
This is because the \emph{DIMACS} input format (described in section \ref{sec:dimacs}) used by most SAT solvers uses integers to refer to variables.

In most cases we have one variable for every bit of the vector.
However, an addition node needs additional carry variables.
On the other hand, for a negation node we don't need to introduce additional variables, as we can simply use the variables already assigned to the operand with reversed polarity.
Similarly for cyclic bit shift we can reuse existing variables but with different ordering.

~\\

Once all variables have been assigned integer values we pass through all the nodes again.
This time we generate the clauses which model the operator behavior.
The number of clauses required depends on the operator and the bit width of the \emph{BitVector} node.

\subsection{Solving and working with solution}
After the model has been turned into an instance we can run a SAT solver on this generated list of clauses and wait for it to terminate.
If the instance is satisfiable the solver will find a satisfying truth assignment and output it as truth values for all the variables.
The library will load, parse and store this data for later use.

We can then easily query any of the \emph{BitVector} variables for its value.
The mapping from variables to integer labels will be used to find the appropriate assignment and to reconstruct the value of the node.

\section{Using the library}
We will demonstrate the use of this library on two examples.
The first one is very simple and shows the entire process from start to finish.
The second example shows a real-world use case -- modifying existing \emph{SHA-1} implementation to use our library for instance generation.
We compare this modified implementation to a hand-crafted one from a previous work.

\subsection{Simple example}
Suppose we wish to find solutions to the boolean equation $X = A \land (B \oplus C)$.
We begin with importing the modeling library and defining the input variables $A$,$B$ and $C$ as $1$-bit vectors:
%\begin{figure}[H]
\begin{minted}[linenos,
			   numbersep=5pt,
               frame=lines,
               framesep=2mm]{python}
from instance import *
A, B, C = BitVector(1), BitVector(1), BitVector(1)
\end{minted}

Next, we can write the expression in the same way as we normally would.
The resulting variable $X$ will also be of type \emph{BitVector} and will store the boolean circuit representing this expression:
\begin{minted}[linenos,
			   firstnumber=3,
			   numbersep=5pt,
               frame=lines,
               framesep=2mm]{python}
X = A & (B ^ C)
\end{minted}

Now we can create a new instance, generate it using the variables we are interested in and solve it using any SAT solver using the \emph{DIMACS} standard.
Afterwards the satisfying assignment is easily accessible through the variables.
In this case we will simply print it out:

\begin{minted}[linenos,
               firstnumber=4,
			   numbersep=5pt,
               frame=lines,
               framesep=2mm]{python}
instance = Instance()
instance.emit([X])
instance.solve(['minisat'])

print([q.getValuation(instance) for q in [A, B, C, X]])
\end{minted}

The output might look like \texttt{[[False], [False], [False], [False]]}, which is indeed a valid solution to our equation.
However, suppose we wish the result $X$ to be true.
We can add this additional constraint by setting

\begin{minted}[linenos,
               firstnumber=4,
			   numbersep=5pt,
               frame=lines,
               framesep=2mm]{python}
X.bits = [True]
\end{minted}

before generating and solving the instance.
Now we obtain the output \texttt{[[True], [False], [True], [True]]} which is another valid solution with the additional property that the value of $X$ is true.

The entire program is less than ten lines long and very straightforward.
We will use the same two concepts -- replacing input variables with \emph{BitVector} and adding additional constraints -- in the next example.

%\caption{a}
%\end{figure}
% - simple example
% - sha1 implementation
%   - compare to nossum
%     - code size/...
%     - generating time?
%     - solving time -> in experiments chapter?
%     - instance size (clauses/vars)