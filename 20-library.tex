\chapter{Modeling library}

The works mentioned in previous chapter created their models for various cryptographic problems mostly by hand.
While the results obtained are interesting, they are hard to reproduce by others.
Also it does not help other in solving similar problems (like using a different hash function instead), as they would have to create their own model from scratch.

To address these issues we provide an easy to use and reusable library for modeling cryptographic problems as SAT instances.
In this chapter we will state our goals for this library, describe its design and inner functionality.
We will also show samples of its use.

\section{Goals}

The main goals of our library are as follows:

\subsection{Existing implementation reuse}
In order to simplify the modeling of cryptographic primitives as much as possible we want to allow reuse of existing implementations.
Most commonly used primitives - such as hash functions, block and stream ciphers and others - have widely available implementations in all popular programming languages.

The library should therefore allow using these implementations with only minor changes.
In addition to saving time this also makes the modeling less error-prone as we can build upon a well tested implementation.

\subsection{Output abstraction}
The library should take care of generating the output in proper format for some SAT solver.
With solvers that support advanced features, such as \emph{XOR} clauses, it should be possible to take advantage of them if the user so wishes.

\subsection{Model parsing}
After successfully solving the instance with a SAT solver we obtain a model in form of a satisfying variable assignment.
The library should be able to load this model and map the truth assignment back to variables defined by the user.
This makes it easy to extract for example the colliding messages out of the model.

\section{Our approach}
