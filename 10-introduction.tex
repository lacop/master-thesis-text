\section{Introduction}

\subsection{SAT solvers}
\emph{SAT solvers} (shortened from \emph{satisfiability}) are programs which take a boolean satisfiability problem and find solution or solutions to this problem.
The problem, which we will call an \emph{instance}, consists of a number of variables and boolean clauses composed of these variables.
The solution, if it exists, is an assignment of truth values to the variables such that the clauses are satisfied.
If no such assignment exists the instance is called \emph{unsatisfiable}.

Most modern SAT solvers expect input in \emph{conjunctive normal form} in which all clauses are disjunctions of literals (at least one literal must be true) and the instance is a conjunction of such clauses (all clauses must be true).
Since this is a normal form we will from now on only consider such instances without loss of generality.

By modeling a decision problem as a SAT instance we can take advantage of the advanced optimizations and heuristics employed by modern SAT solvers.
Examples of such uses in practice include formal program verification, model checking or even routing of connections in microchips.
%TODO refs for use cases

\subsubsection{Interfacing with SAT solvers}
\label{sec:dimacs}
Since our work depends on providing a suitable input to SAT solvers we will briefly describe the widely supported \emph{DIMACS\footnote{As in the case of \emph{JPEG} the acronym refers to the institute that created the format -- the \emph{Center for Discrete Mathematics and Theoretical Computer Science.}} CNF} format which we use.
Later in section \ref{sec:branching-order} we will describe extending this format for optimization purposes.

The file begins with a line in form \texttt{p cnf $vars$ $clauses$} where $vars$ and $clauses$ are the number of variables and clauses in this instance, respectively.

The following lines are in the form \texttt{$v_1$\dots$v_i$ 0} and each represents a single clause consisting of a disjunction of literals $v_1$ through $v_i$.
Each literal $v_i$ is an integer between $1$ and $vars$ for a variable in positive polarity or an integer between $-1$ and $-vars$ for negative polarity.

The output for a satisfiable instance is a list of $vars$ numbers.
For every $1 \le v_i \le vars$ either $v_i$ or $-v_i$ is present in the list, indicating the polarity of the $i$-th variable in (one of) the satisfying assignment. 

\subsection{Cryptographic problems}
In our work we make use of SAT solvers to find solutions to instances which represent a cryptographic primitive.
By placing additional restrictions on the possible solutions (by introducing more clauses) we can find a truth assignment that gives us the desired inputs and outputs to the cryptographic primitive.
With a stream cipher this can mean finding the secret key (input) by restricting the output to observed keystream.

In our work we will focus specifically on hash functions.

\subsubsection{Hash functions}
TODO ~0.5pgs
%TODO copy from old text?
%A \emph{hash function} is a function 

\subsection{Related work}
TODO ~1.5gs + tabulka
%TODO nice summary + large table + references

\subsection{Boolean circuits}
The cryptographic primitive we want to encode into a SAT instance can be thought of as a \emph{boolean circuit} -- a \emph{DAG} (directed acyclic graph) in which vertices are boolean operators (\emph{gates}, such as the \emph{AND gate}, \emph{XOR gate} and so on).
The edges represent flow of values from one gate to another.
\emph{Inputs} are special vertices that have no incoming edges.
\emph{Outputs} are also special vertices that have exactly one incoming edge and no outgoing edges.

Given this representation the simplest way to encode this as a CNF formula would be to take each output vertex and recursively expand it in the following way:
At first we start with an output vertex $v$ encoded as $(v)$.
This will have one incoming edge from a gate vertex $g$ with inputs $x_1, \dots, x_k$.
We will encode this as $g(x_1, \dots, x_k)$ where $g$ is the appropriate boolean operation of the gate -- for example, if the output vertex is connected to an \emph{AND} gate this would be $(x_1 \land \dots \land x_k)$.

Now we repeat this process recursively, expanding each gate node until the encoding only refers to the input vertices.
The resulting encoding has to be converted into conjunctive normal form and can then be solved with any SAT solver.

However, this approach produces very large output formula with many clauses.
Since we are recursively expanding each vertex until we reach the input vertices, large subgraphs which are referenced (connected by an outgoing edge) multiple times will needlessly be repeated in the output encoding.
The total length of the formula then can be exponential in the size of the input circuit.
%TODO exponential example

\subsubsection{Tseitin transformation}
\label{sec:tseitin}
To reduce the number of clauses of the resulting encoding we can use the \emph{Tseitin transformation} \cite{tseitin1983complexity}.
Instead of generating a large number of clauses when expanding the circuit we will add a new variable for each vertex.

Each gate vertex can then be encoded as a boolean function with constant number of clauses using only variables corresponding to gates (or inputs) that are connected via an incoming edge.
The following table shows how to encode the most popular boolean gates with two inputs $A$ and $B$.
Variable $C$ refers to the new variable representing this gate in the encoding.

\begin{tabular}{r c l}
\emph{AND}& $A\land B$ & $(C \lor \overline{A} \lor \overline{B}) \land (\overline{C} \lor A) \land (\overline{C} \lor B)$ \\
\emph{OR} & $A\lor B$ & $(\overline{C} \lor A \lor B) \land (C \lor \overline{A}) \land (C \lor \overline{B})$ \\
\emph{XOR} & $A\oplus B$ & $(\overline{C} \lor \overline{A} \lor \overline{B}) \land (\overline{C} \lor A \lor B) \land$\\
& & $(C \lor \overline{A} \lor B) \land (C \lor A \lor \overline{B})$
\end{tabular}

Other binary gates such as \emph{NAND} can be encoded similarly.
In case of multiple inputs we can either extend this encoding or replace the n-ary gates with multiple binary ones.
%However, the \emph{XOR} gate will have number of clauses exponential in the number of variables.

This encoding produces formula with linear number of variables and linear length with respect to the size of the boolean circuit.

\subsubsection{Arithmetic gates}
Most cryptographic algorithms make heavy use of arithmetic operations, such as modular addition.
These usually work on variables of some fixed size, for example 32-bit integers.

The n-bit variable can be represented using n binary variables in the SAT instance.
However, these operations can not be performed on individual bits like with the boolean operators.
We need to introduce additional helper variables that will represent the carry bits during the addition operation.

This can be thought of as taking the boolean circuit for a binary adder with carry (either ripple-carry or lookahead-carry), composed of several full-adder circuits.
These can then be encoded using the Tseitin transformation.

However, for simplicity we extend our model of boolean circuits to support modular addition nodes directly.
When encoding these nodes to CNF we then use the additional carry variables and output the clauses required to model a binary adder.

%TODO adders, xor clauses ...

% sat solvers
%  - solve any decision problem
%  - input usualy as cnf
%  - DIMACS format example and semantics (move here?)
%  - advanced heuristics etc
%  - DPLL / ... ? if too short
%
% crypto problems
%  - decision problems as well, can use sat
%  - will focus on hash functions
%
% hash functions
%  - basic idea
%  - attacks
%  - reduced rounds
%  - relevant functions for us (sha family)
% 
% existing work survey