\section{Introduction}

\subsection{SAT solvers}
\emph{SAT solvers} (shortened from \emph{satisfiability}) are programs which take a boolean satisfiability problem and find solution or solutions to this problem.
The problem, which we will call an \emph{instance}, consists of a number of variables and boolean clauses composed of these variables.
The solution, if it exists, is an assignment of truth values to the variables such that the clauses are satisfied.
If no such assignment exists the instance is called \emph{unsatisfiable}.

Most modern SAT solvers expect input in \emph{conjunctive normal form} in which all clauses are disjunctions of literals (at least one literal must be true) and the instance is a conjunction of such clauses (all clauses must be true).
Since this is a normal form we will from now on only consider such instances without loss of generality.

By modeling a decision problem as a SAT instance we can take advantage of the advanced optimizations and heuristics employed by modern SAT solvers.
Examples of such uses in practice include formal program verification, model checking or even routing of connections in microchips.
%TODO refs for use cases

\subsubsection{Interfacing with SAT solvers}
Since our work depends on providing a suitable input to SAT solvers we will briefly describe the widely supported \emph{DIMACS\footnote{As in the case of \emph{JPEG} the acronym refers to the institute that created the format -- the \emph{Center for Discrete Mathematics and Theoretical Computer Science.}} CNF} format which we use.
Later in section \ref{sec:branching-order} we will describe extending this format for optimization purposes.

The file begins with a line in form \texttt{p cnf $vars$ $clauses$} where $vars$ and $clauses$ are the number of variables and clauses in this instance, respectively.

The following lines are in the form \texttt{$v_1$\dots$v_i$ 0} and each represents a single clause consisting of a disjunction of literals $v_1$ through $v_i$.
Each literal $v_i$ is an integer between $1$ and $vars$ for a variable in positive polarity or an integer between $-1$ and $-vars$ for negative polarity.

The output for a satisfiable instance is a list of $vars$ numbers.
For every $1 \le v_i \le vars$ either $v_i$ or $-v_i$ is present in the list, indicating the polarity of the $i$-th variable in (one of) the satisfying assignment. 

\subsection{Cryptographic problems}
In our work we make use of SAT solvers to find solutions to instances which represent a cryptographic primitive.
By placing additional restrictions on the possible solutions (by introducing more clauses) we can find a truth assignment that gives us the desired inputs and outputs to the cryptographic primitive.
With a stream cipher this can mean finding the secret key (input) by restricting the output to observed keystream.

In our work we will focus specifically on hash functions.

\subsubsection{Hash functions}
%TODO copy from old text?
%A \emph{hash function} is a function 

\subsection{Related work}
%TODO nice summary + large table + references

% sat solvers
%  - solve any decision problem
%  - input usualy as cnf
%  - DIMACS format example and semantics (move here?)
%  - advanced heuristics etc
%  - DPLL / ... ? if too short
%
% crypto problems
%  - decision problems as well, can use sat
%  - will focus on hash functions
%
% hash functions
%  - basic idea
%  - attacks
%  - reduced rounds
%  - relevant functions for us (sha family)
% 
% existing work survey