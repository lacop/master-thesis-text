\section{Introduction}

\subsection{SAT solvers}
\emph{SAT solvers} (shortened from \emph{satisfiability}) are programs which take a boolean satisfiability problem and find solution or solutions to this problem.
The problem, which we will call an \emph{instance}, consists of a number of variables and boolean clauses composed of these variables.
The solution, if it exists, is an assignment of truth values to the variables such that the clauses are satisfied.
If no such assignment exists the instance is called \emph{unsatisfiable}.

Most modern SAT solvers expect input in \emph{conjunctive normal form} in which all clauses are disjunctions of literals (literal is either a variable or a negation of a variable, and at least one literal must be true) and the instance is a conjunction of such clauses (all clauses must be true).
As the name suggests this is a normal form, which means every boolean expression can be converted to an equivalent one that satisfies these requirements.
Thus we will from now on only consider such instances without loss of generality.

By modeling a decision problem as a SAT instance we can take advantage of the advanced optimizations and heuristics employed by modern SAT solvers.
Examples of such uses in practice include formal program verification, model checking or even routing of connections in microchips.
%TODO refs for use cases

\subsubsection{Interfacing with SAT solvers}
\label{sec:dimacs}
Since our work depends on providing a suitable input to SAT solvers we will briefly describe the widely supported \emph{DIMACS\footnote{As in the case of \emph{JPEG} the acronym refers to the institute that created the format -- the \emph{Center for Discrete Mathematics and Theoretical Computer Science.}} CNF} format which we use.
Later in section \ref{sec:branching-order} we will describe extending this format for optimization purposes.

The file begins with a line in form

\centerline{\texttt{p cnf $vars$ $clauses$}}

\noindent where $vars$ and $clauses$ are the number of variables and clauses in this instance, respectively.

The following lines are in the form

\centerline{\texttt{$v_1$\dots$v_i$ 0}}

\noindent and each represents a single clause consisting of a disjunction of literals $v_1$ through $v_i$.
Each literal $v_i$ is an integer between $1$ and $vars$ for a variable in positive polarity or an integer between $-1$ and $-vars$ for negative polarity.

The output for a satisfiable instance is a list of $vars$ numbers.
For every $1 \le v_i \le vars$ either $v_i$ or $-v_i$ is present in the list, indicating the polarity of the $i$-th variable in (one of) the satisfying assignment. 

\subsection{Cryptographic problems}
We make use of SAT solvers to find solutions to instances which represent a cryptographic primitive.
By placing additional restrictions on the possible solutions (by introducing more clauses) we can find a truth assignment that gives us the desired inputs and outputs to the cryptographic primitive.
With a cipher this can mean finding the secret key (input) by restricting the output to observed keystream.
With hash functions this can mean reversing the output for an \emph{preimage} attack or finding two different input with the same output (a \emph{collision}).

In our work we will focus specifically on hash functions, which we describe in more detail in the following section.

\subsubsection{Hash functions}
TODO ~0.5pgs
%TODO copy from old text?
%A \emph{hash function} is a function 

\subsection{Encoding}
The most important step when using SAT solvers for any problem is the encoding of the model to a suitable instance.
In case of cryptographic problems this previously (see section \ref{sec:related-work}) required significant effort of either generating the SAT instance by hand, or by first translating the model to a more suitable form and then using existing tools to generate the instance.

In our work we created a library which automates large parts of this process.
This makes it easier, faster and less error-prone.
To achieve this goal we made of \emph{boolean circuit} representation to translate almost unmodified implementations of cryptographic primitives to SAT instances transparently.

\subsubsection{Boolean circuits}
The cryptographic primitive we want to encode into a SAT instance can be thought of as a \emph{boolean circuit} -- a \emph{DAG} (directed acyclic graph) in which vertices are boolean operators (\emph{gates}, such as the \emph{AND gate}, \emph{XOR gate} and so on).
The edges represent flow of values from one gate to another.
\emph{Inputs} are special vertices that have no incoming edges.
\emph{Outputs} are also special vertices that have exactly one incoming edge and no outgoing edges.

Given this representation the simplest way to encode this as a CNF formula would be to take each output vertex and recursively expand it in the following way:
At first we start with an output vertex $v$ encoded as $(v)$.
This will have one incoming edge from a gate vertex $g$ with inputs $x_1, \dots, x_k$.
We will encode this as $g(x_1, \dots, x_k)$ where $g$ is the appropriate boolean operation of the gate -- for example, if the output vertex is connected to an \emph{AND} gate this would be $(x_1 \land \dots \land x_k)$.

Now we repeat this process recursively, expanding each gate node until the encoding only refers to the input vertices.
The resulting encoding has to be converted into conjunctive normal form and can then be solved with any SAT solver.

However, this approach produces very large output formula with many clauses.
Since we are recursively expanding each vertex until we reach the input vertices, large subgraphs which are referenced (connected by an outgoing edge) multiple times will needlessly be repeated in the output encoding.
The total length of the formula then can be exponential in the size of the input circuit.
%TODO exponential example

\subsubsection{Tseitin transformation}
\label{sec:tseitin}
To reduce the number of clauses of the resulting encoding we can use the \emph{Tseitin transformation} \cite{tseitin1983complexity}.
Instead of generating a large number of clauses when expanding the circuit we will add a new variable for each vertex.

Each gate vertex can then be encoded as a boolean function with constant number of clauses using only variables corresponding to gates (or inputs) that are connected via an incoming edge.
The following table shows how to encode the most common boolean gates with two inputs $A$ and $B$.
Variable $C$ refers to the new variable representing this gate in the encoding.

\begin{tabular}{r c l}
\emph{AND}& $A\land B$ & $(C \lor \overline{A} \lor \overline{B}) \land (\overline{C} \lor A) \land (\overline{C} \lor B)$ \\
\emph{OR} & $A\lor B$ & $(\overline{C} \lor A \lor B) \land (C \lor \overline{A}) \land (C \lor \overline{B})$ \\
\emph{XOR} & $A\oplus B$ & $(\overline{C} \lor \overline{A} \lor \overline{B}) \land (\overline{C} \lor A \lor B) \land$\\
& & $(C \lor \overline{A} \lor B) \land (C \lor A \lor \overline{B})$
\end{tabular}

Other binary gates such as \emph{NAND} can be encoded similarly.
In case of multiple inputs we can either extend this encoding or replace the $n$-ary gates with multiple binary ones.
%However, the \emph{XOR} gate will have number of clauses exponential in the number of variables.

This encoding produces formula with linear number of variables and linear length with respect to the size of the boolean circuit, if we limit the it to unary and binary gates.

\subsubsection{Arithmetic gates}
Most cryptographic algorithms make heavy use of arithmetic operations, such as modular addition.
These usually work on variables of some fixed size, for example 32-bit integers.

The $n$-bit variable can be represented using $n$ binary variables in the SAT instance.
However, these operations can not be performed on individual bits like in the case of boolean operators.
We need to introduce additional helper variables that will represent the carry bits during the addition operation.

This can be thought of as taking the boolean circuit for a binary adder with carry (either ripple-carry or lookahead-carry), composed of several full-adder circuits.
These can then be encoded using the Tseitin transformation.

However, for simplicity we extend our model of boolean circuits to support modular addition nodes directly.
When encoding these nodes to CNF we use the additional carry variables and output the clauses required to model a binary adder.

%TODO adders, xor clauses ...

\subsection{Related work}
\label{sec:related-work}
The idea of using SAT solvers for cryptographic problems was first introduced in \cite{massacci2000logical}.
The authors designed an encoding of the \emph{DES} (\emph{Data Encryption Standard}) symmetric cipher and created a program to generate instances.
However the work is very specific to \emph{DES} and modifying the tool for a different cipher would require significant changes.

The first attempt to simplify this process can be found in \cite{jovanovic2005logical} where \emph{operator overloading} (see section \ref{sec:operator-overloading}) in the \emph{C++} language is used.
Our library also makes use of this feature with the additional advantage that we use a \emph{dynamic} programming language (\emph{Python}) and therefore require smaller changes to existing code.
Additionally their work uses only simple Tseitin transform without additional optimizations, and the code for the tool is not available.
%TODO verify again not available...

Another work which automates the generation of instances makes use of the \emph{Verilog} hardware description language\footnote{HDLs describe the behavior of logic circuits. They are used for programming FPGAs or designing ASICs.} \cite{morawiecki2013sat}.
After writing the cryptographic primitive in this language a free, but proprietary, compiler is used to generate equations which are then turned to a CNF instance.
Since \emph{Verilog} is quite a niche language most cryptographic primitives do not have implementations available.
Additionally the toolkit itself is also not available.

An in-depth analysis of \emph{SHA-1} preimage attacks was done in \cite{nossum2012sat}.
The instances were generated using a custom, hand-built 1000-line \emph{C++} program.
The experiments investigated the speed of various SAT solvers, effects of preprocessing and simplifying the instance and various heuristics.

Further related works can be found in the bibliography.

%TODO dalsie refs/tabulka? ~0.25pgs
%TODO nice summary + large table + references


% sat solvers
%  - solve any decision problem
%  - input usualy as cnf
%  - DIMACS format example and semantics (move here?)
%  - advanced heuristics etc
%  - DPLL / ... ? if too short
%
% crypto problems
%  - decision problems as well, can use sat
%  - will focus on hash functions
%
% hash functions
%  - basic idea
%  - attacks
%  - reduced rounds
%  - relevant functions for us (sha family)
% 
% existing work survey